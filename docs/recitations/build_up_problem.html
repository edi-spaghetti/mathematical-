
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Build Up Error &#8212; maths 6.042 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Travelling Salesperson" href="travelling_salesperson.html" />
    <link rel="prev" title="A Protocol For College Admission" href="stable_marriage_problem.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="build-up-error">
<h1>Build Up Error<a class="headerlink" href="#build-up-error" title="Permalink to this headline">¶</a></h1>
<p><strong>Recall a graph is connected iff there is a path between every pair of its vertices.</strong></p>
<blockquote>
<div><p>False Claim. If every vertex in a graph has positive degree, then the graph is connected.</p>
</div></blockquote>
<ol class="arabic">
<li><p><strong>Prove that this Claim is indeed false by providing a counterexample</strong></p>
<blockquote>
<div><hr><div class="graphviz"><img src="../_images/graphviz-c1c7d7c457a671d1d201d864b9337eadafb839f7.png" alt="graph counterexample {
A -- B

C -- D
}" class="graphviz" /></div>
<p>All nodes have a degree of 1, but there is no path from A or B to C or D.</p>
</div></blockquote>
</li>
<li><p><strong>Since the Claim is false, there must be a logical mistake in the following bogus proof. Pinpoint the first logical mistake (unjustified step) in the proof.</strong></p>
<blockquote>
<div><p><strong>Proof</strong>. We prove the Claim above by induction.
Let P(n) be the proposition that if every vertex in an n-vertex graph has positive degree, then the graph is connected.</p>
<p><strong>Base cases</strong>: (<span class="math notranslate nohighlight">\(n \le 2\)</span>). In a graph with 1 vertex, that vertex cannot have positive degree, so P(1) holds vacuously.</p>
<p>P(2) holds because there is only one graph with two vertices of positive degree,
namely, the graph with an edge between the vertices, and this graph is connected.</p>
<p><strong>Inductive step</strong>: We must show that <span class="math notranslate nohighlight">\(P(n)\)</span> implies <span class="math notranslate nohighlight">\(P(n + 1)\)</span> for all <span class="math notranslate nohighlight">\(n \ge 2\)</span>.
Consider an n-vertex graph in which every vertex has positive degree.
By the assumption P(n), this graph is connected; that is, there is a path between every pair of vertices.
Now we add one more vertex x to obtain an (n + 1)-vertex graph:</p>
<img alt="../_images/n-vertex.png" class="align-center" src="../_images/n-vertex.png" />
<p>All that remains is to check that there is a path from x to every other vertex z.
Since x has positive degree, there is an edge from x to some other vertex, y.
Thus, we can obtain a path from x to z by going from x to y and then following the path from y to z.
This proves P(n + 1).</p>
<p>By the principle of induction, P(n) is true for all <span class="math notranslate nohighlight">\(n \ge 0\)</span>, which proves the Claim. <span class="math notranslate nohighlight">\(\square\)</span></p>
<hr><p>The error is in the base cases. P(1) asserts that the vertex cannot have a positive degree, so holds vacuously.
But it does not, because there are no paths between every node in the graph (there are no paths at all!)</p>
<p>The second error could be that P(2) holds because it just so happens to be an n-complete graph at that point,
because 1 edge is required for a 2-node graph.</p>
<p>This is related to the real issue where they conclude P(n + 1) have been proven.
P(n + 1) must be true for every (n + 1)-node graph, not just one built up from an n-node connected graph.</p>
</div></blockquote>
</li>
</ol>
<section id="the-grow-algorithm">
<h2>The Grow Algorithm<a class="headerlink" href="#the-grow-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Yesterday in lecture, we saw the following algorithm for constructing a minimum-weight spanning tree (MST) from an edge-weighted N-vertex graph G.</p>
<p>ALG-GROW:</p>
<ol class="arabic simple">
<li><p>Label the edges of the graph <span class="math notranslate nohighlight">\(e_1, e_2, \dots , e_t \text{ so that } w_t(e_1) \le w_t(e_2) \dots \le w_t(e_t)\)</span>.</p></li>
<li><p>Let S be the empty set.</p></li>
<li><p>For <span class="math notranslate nohighlight">\(i = 1 \dots t\)</span>, if <span class="math notranslate nohighlight">\(S \cup \{e_i\}\)</span> does not contain a cycle, then extend S with the edge <span class="math notranslate nohighlight">\(e_i\)</span>.</p></li>
<li><p>Output S.</p></li>
</ol>
<p>In summary, ALG-GROW selects edges one at a time, always choosing the minimum weight edge that does not create a cycle with previously selected edges.
Notice that as edges are added S may not be connected.
When the algorithm terminates, S contains N −1 edges.
If it is connected, then it is a spanning tree.
Consider, for example, the following edge-weighted graph.</p>
<img alt="../_images/edge-weighted.png" class="align-center" src="../_images/edge-weighted.png" />
<p>Now suppose we run ALG-GROW on our graph.
We may choose the weight 1 edge on the bottom of the triangle of weight 1 edges in our graph.
In the next step, we may choose the weight 1 edge on the top of the graph.
Note that this edge still has minimum weight, and does not cause us to form a cycle, so ALG-GROW can choose it.
We will then choose one of the remaining weight 1 edges.
Note that neither causes us to form a cycle.
Continuing the algorithm, we may end up with the same spanning tree shown below</p>
<img alt="../_images/spanning-tree.png" class="align-center" src="../_images/spanning-tree.png" />
<p>In this recitation, we will analyze ALG-GROW.</p>
</section>
<section id="analysis-of-alg-grow">
<h2>Analysis of ALG-GROW<a class="headerlink" href="#analysis-of-alg-grow" title="Permalink to this headline">¶</a></h2>
<p>In this problem you may assume the following lemma from the problem set:</p>
<p><strong>Lemma 1</strong>. Suppose that <span class="math notranslate nohighlight">\(T = (V, E)\)</span> is a simple, connected graph.
Then T is a tree iff <span class="math notranslate nohighlight">\(|E| = |V | − 1\)</span>.</p>
<p>In this exercise you will prove the following theorem.</p>
<p><strong>Theorem</strong>. For any connected, weighted graph G, ALG-GROW produces an MST of G.</p>
<ol class="loweralpha">
<li><p>Prove the following lemma.</p>
<blockquote>
<div><p><strong>Lemma 2</strong>. Let <span class="math notranslate nohighlight">\(T = (V, E)\)</span> be a tree and let e be an edge not in E.
Then, <span class="math notranslate nohighlight">\(G = (V, E \cup \{e\}\)</span>) contains a cycle.</p>
<p>(Hint: Suppose G does not contain a cycle. Is G a tree?)</p>
<hr><p><strong>Proof</strong>. By contradiction.
Suppose G does not contain a cycle. Then the edge, e, added to T, must be incident to two nodes,
<span class="math notranslate nohighlight">\(x,y \in V\)</span> that were not previously connected.
However, since G is a tree, by definition it is connected, meaning there is already a path from <span class="math notranslate nohighlight">\(x—...—y\)</span>.
Adding a new edge directly from x to y would create a cycle <span class="math notranslate nohighlight">\(x—...—y—x\)</span>.
This a contradiction, so we can conclude that G contains a cycle.</p>
</div></blockquote>
</li>
<li><p>Prove the following lemma.</p>
<blockquote>
<div><p><strong>Lemma 3</strong>. Let <span class="math notranslate nohighlight">\(T = (V, E)\)</span> be a spanning tree of G and let e be an edge not in E.
Then there exists an edge <span class="math notranslate nohighlight">\(e' \ne e\)</span> in E such that <span class="math notranslate nohighlight">\(T∗ = (V, E − \{e'\} \cup \{e\})\)</span> is a spanning tree of G.</p>
<p>(Hint: Adding e to E introduces a cycle in <span class="math notranslate nohighlight">\((V, E \cup \{e\})\)</span>.)</p>
<hr><p>By Lemma 2, we know <span class="math notranslate nohighlight">\(E \cup e\)</span> contains a cycle. Therefore when we remove <span class="math notranslate nohighlight">\(e'\)</span> there are two options;
Case 1: There is still a cycle. But then the edges must be a subset of E. And the edges in E form the tree T, so this cannot happen.
Case 2: There is no longer a cycle. So the cycle contained e and <span class="math notranslate nohighlight">\(e'\)</span>.
Removing an edge from a cycle means all the nodes are still connected in the other direction.</p>
<p>Since T* contains all the same nodes at T, it is also a spanning tree of G.</p>
</div></blockquote>
</li>
<li><p>Prove the following lemma.</p>
<blockquote>
<div><p><strong>Lemma 4</strong>. Let <span class="math notranslate nohighlight">\(T = (V, E)\)</span> be a spanning tree of G, let e be an edge not in E
and let <span class="math notranslate nohighlight">\(S \subseteq E\)</span> such that <span class="math notranslate nohighlight">\(S \cup \{e\}\)</span> does not contain a cycle.
Then there exists an edge <span class="math notranslate nohighlight">\(e' \ne e\)</span> in <span class="math notranslate nohighlight">\(E − S\)</span> such that <span class="math notranslate nohighlight">\(T∗ = (V, E − \{e'\} \cup \{e\})\)</span> is a spanning tree of G.</p>
<p>(Hint: Modify your proof to part (b). Of all possible edges <span class="math notranslate nohighlight">\(e' \ne e\)</span> that can be removed to construct T∗, at least one is not in S.)</p>
<hr><p>We know that <span class="math notranslate nohighlight">\(E \cup e\)</span> contains a cycle. Since <span class="math notranslate nohighlight">\(S \cup \{e\}\)</span> doesn’t contain a cycle,
we can conclude that <span class="math notranslate nohighlight">\(1 \ge |S| &lt; |E|\)</span> edges and <span class="math notranslate nohighlight">\(e' \ni S\)</span>.
We can prove this by contradiction. Suppose that all the edges <span class="math notranslate nohighlight">\(\ne e\)</span> in the cycle of <span class="math notranslate nohighlight">\(E \cup e\)</span> are in S.
The S must contain a cycle, but this contradicts the assumptions.</p>
</div></blockquote>
</li>
<li><p>Prove the following lemma.</p>
<blockquote>
<div><p><strong>Lemma 5</strong>. Define <span class="math notranslate nohighlight">\(S_m\)</span> to be the set consisting of the first m edges selected by ALGGROW from a connected graph G.
Let <span class="math notranslate nohighlight">\(P(m)\)</span> be the predicate that if <span class="math notranslate nohighlight">\(m \le |V|\)</span> then <span class="math notranslate nohighlight">\(S_m \subseteq E\)</span> for some MST <span class="math notranslate nohighlight">\(T = (V, E)\)</span> of G.
Then <span class="math notranslate nohighlight">\(\forall m. P(m)\)</span>.</p>
<p>(Hint: Use induction. There are two cases: <span class="math notranslate nohighlight">\(m + 1 &gt; |V| \text{ and } m + 1 \le |V|\)</span>.
In the second case, there are two subcases.)</p>
<hr><p><strong>Theorem</strong> P(m) as defined above</p>
<p><strong>Base Case</strong>: We must show P(0). Since we’re on the 0th step, no edges have been chosen yet.
So <span class="math notranslate nohighlight">\(S_m = \emptyset\)</span>, which is trivally true.</p>
<p><strong>Inductive Step</strong>: We must show P(n+1) assuming P(n).</p>
<p>When we add the <span class="math notranslate nohighlight">\((n+1)^{th}\)</span> edge, there are two cases;</p>
<p>Case 1: If <span class="math notranslate nohighlight">\(m &gt; |V|\)</span> then <span class="math notranslate nohighlight">\(m \ge |V|\)</span>. This means every node is connected already by <span class="math notranslate nohighlight">\(S_m\)</span>.
By P(m) we already know <span class="math notranslate nohighlight">\(T* = (V, S_m)\)</span> is a minimum spanning tree of G.
By Lemma 2 we know that adding any new edge to a tree results in a cycle.
However by the algorithm, we only add an edge if it doesn’t result in a cycle.
So the <span class="math notranslate nohighlight">\((n+1)^{th}\)</span> edge is not added to <span class="math notranslate nohighlight">\(S_m\)</span>, keeping <span class="math notranslate nohighlight">\(S_m\)</span> a subset of E.</p>
<p>Case 2: If <span class="math notranslate nohighlight">\(m + 1 \le |V|\)</span> then <span class="math notranslate nohighlight">\(m &lt; |V|\)</span>.
By P(m) we know <span class="math notranslate nohighlight">\(S_m \subseteq E\)</span>. Let e denote the <span class="math notranslate nohighlight">\((n+1)^{th}\)</span> edge.
There are now two subcases,</p>
<p>First, <span class="math notranslate nohighlight">\(e \in E\)</span>, in which case <span class="math notranslate nohighlight">\(S_{m+1} \in E\)</span> so P(m+1) holds.</p>
<p>Second, <span class="math notranslate nohighlight">\(e \ni E\)</span>. By the description of ALG-GROW, if e is not in the final set of edges E,
it’s because <span class="math notranslate nohighlight">\(S_m \cup e\)</span> would result in a cycle.
So e is not added to <span class="math notranslate nohighlight">\(S_m\)</span> and <span class="math notranslate nohighlight">\(S_m\)</span> remains a subset of E.</p>
<p>However, assuming <span class="math notranslate nohighlight">\(S_m \cup e\)</span> does not contain a cycle,
by Lemma 4 there exists an edge <span class="math notranslate nohighlight">\(e'\)</span> in the remaining edges of E (<span class="math notranslate nohighlight">\(E - S_m\)</span>)
such that swapping out <span class="math notranslate nohighlight">\(e'\)</span> for <span class="math notranslate nohighlight">\(e\)</span> in T will give us a spanning tree <span class="math notranslate nohighlight">\(T** = (V, E - \{e'\} \cup \{e\})\)</span> for G.</p>
<p>We must therefore prove that because <span class="math notranslate nohighlight">\(weight(e) \le weight(e')\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This really confuses me. If e weighs less than <span class="math notranslate nohighlight">\(e'\)</span>, and adding it to <span class="math notranslate nohighlight">\(S_m\)</span> doesn’t result in a cycle,
why didn’t we add it to <span class="math notranslate nohighlight">\(S_m\)</span> (and by extension, why isn’t e in E?)</p>
</div>
</div></blockquote>
</li>
<li><p>Prove the theorem.</p>
<blockquote>
<div><p>(Hint: Lemma 5 says there exists an MST <span class="math notranslate nohighlight">\(T = (V, E)\)</span> for G such that <span class="math notranslate nohighlight">\(S \subseteq E\)</span>.
Use contradiction to rule out the case in which S is a proper subset of E.)</p>
<hr><p>Suppose that <span class="math notranslate nohighlight">\(S \ne E\)</span>. Then there exists at least one edge, e, in <span class="math notranslate nohighlight">\(E - S\)</span>.
Since the edges in E are the edges of a tree, <span class="math notranslate nohighlight">\(S \cup e \subseteq E\)</span> does not contain a cycle.
But then ALG-GROW would have added it to S, so e must be in S. Which contradicts <span class="math notranslate nohighlight">\(e \in E - S\)</span></p>
</div></blockquote>
</li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">maths</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Recitations</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="induction.html">Induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="state_machines.html">State Machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="greatest_common_divisor.html">Greatest Common Divisors</a></li>
<li class="toctree-l2"><a class="reference internal" href="exponentiation_modular_arithmetic_RSA.html">RSA</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_basics.html">Graph Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="stable_marriage_problem.html">A Protocol For College Admission</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Build Up Error</a></li>
<li class="toctree-l2"><a class="reference internal" href="travelling_salesperson.html">Travelling Salesperson</a></li>
<li class="toctree-l2"><a class="reference internal" href="networks.html">Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="relations.html">Equivalence Relations</a></li>
<li class="toctree-l2"><a class="reference internal" href="doubles.html">Doubles</a></li>
<li class="toctree-l2"><a class="reference internal" href="asymptotics.html">Asymptotic Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="asymptotics.html#asymptotic-equivalence">Asymptotic Equivalence</a></li>
<li class="toctree-l2"><a class="reference internal" href="asymptotics.html#more-asymptotic-notation">More Asymptotic Notation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../assignments/index.html">Assignments</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Recitations</a><ul>
      <li>Previous: <a href="stable_marriage_problem.html" title="previous chapter">A Protocol For College Admission</a></li>
      <li>Next: <a href="travelling_salesperson.html" title="next chapter">Travelling Salesperson</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Edward Spencer.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/recitations/build_up_problem.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>